//
// The MIT License (MIT)
//
// Copyright (c) 2016 GoDaddy Operating Company, LLC.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#include <map>
#include <mutex>
#include <string>

#include "procfilter/procfilter.h"

class ProcessData {
public:
	ProcessData(const WCHAR *lpszPathName) : path {lpszPathName} {}
	ProcessData() : path {} {}

	std::wstring path;
};

std::map<DWORD, ProcessData> g_PidPdMap;
std::mutex g_PidPdMap_mtx;

bool
DumpProcessMemory(PROCFILTER_EVENT *e, const WCHAR *lpszFileName)
{
	PEB Peb;
	PEB_LDR_DATA LoaderData;
	LIST_ENTRY Link;
	LDR_DATA_TABLE_ENTRY LoaderDataTableEntry;
	bool rv = true;

	if (e->ReadProcessPeb(&Peb) &&
		e->ReadProcessMemory(Peb.Ldr, &LoaderData, sizeof(LoaderData)) &&
		e->ReadProcessMemory(LoaderData.InMemoryOrderModuleList.Flink, &Link, sizeof(Link)) &&
		e->ReadProcessMemory(CONTAINING_RECORD(Link.Flink, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks), &LoaderDataTableEntry, sizeof(LoaderDataTableEntry))) {
			
			SYSTEM_INFO si;
			GetSystemInfo(&si);
			DWORD dwPageSize = si.dwPageSize;
			BYTE *lpRemoteBaseAddress = (BYTE*)LoaderDataTableEntry.DllBase;

			HANDLE hMemoryDump = CreateFileW(lpszFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_NEW, 0, NULL);
			if (hMemoryDump != INVALID_HANDLE_VALUE) {
				BYTE *lpbaCurrentPage = (BYTE*)_alloca(dwPageSize);
				DWORD dwBytesWritten = 0;
				size_t nPages = 0;
				BOOL rc = FALSE;
				while (e->ReadProcessMemory(&lpRemoteBaseAddress[nPages * dwPageSize], lpbaCurrentPage, dwPageSize) &&
						(rc = WriteFile(hMemoryDump, lpbaCurrentPage, dwPageSize, &dwBytesWritten, NULL)) == TRUE && dwBytesWritten == dwPageSize) {
							++nPages;
				}

				if (rc == TRUE && dwBytesWritten == 0) {
					rv = true;
				}

				CloseHandle(hMemoryDump);
			}
	}

	return rv;
}


inline
bool
IsPathSeparator(WCHAR c)
{
	return c == '\\' || c == '/';
}


bool
ContainsWatchedDirectoryName(const WCHAR *lpszPath, const WCHAR *lpszSubdirectory)
{
	size_t len = wcslen(lpszPath);
	size_t sslen = wcslen(lpszSubdirectory);
	if (len < sslen) return false;

	for (size_t i = 0; i < len - sslen; ++i) {
		if (_wcsnicmp(&lpszPath[i], lpszSubdirectory, sslen) == 0) {
			if ((i == 0 || IsPathSeparator(lpszPath[i-1])) && IsPathSeparator(lpszPath[i+sslen])) {
				return true;
			}
		}
	}

	return false;
}


DWORD
ProcFilterEvent(PROCFILTER_EVENT *e)
{
	DWORD dwResultFlags = PROCFILTER_RESULT_NONE;
	static WCHAR szMalwareDirName[MAX_PATH+1] = {0};
	static bool bWatchElevatedThreads = false;

	if (e->dwEventId == PROCFILTER_EVENT_INIT) {
		e->RegisterPlugin(PROCFILTER_VERSION, L"Antimalware", 0, 0, false,
			PROCFILTER_EVENT_PROCESS_CREATE,
			PROCFILTER_EVENT_PROCESS_TERMINATE,
			PROCFILTER_EVENT_THREAD_CREATE,
			PROCFILTER_EVENT_THREAD_TERMINATE,
			PROCFILTER_EVENT_IMAGE_LOAD,
			PROCFILTER_EVENT_NONE);
		e->GetConfigString(L"MalwareDirectory", L"malware", szMalwareDirName, sizeof(szMalwareDirName));
		bWatchElevatedThreads = e->GetConfigBool(L"MalwareDirectory", false);
	} else if (e->dwEventId == PROCFILTER_EVENT_PROCESS_CREATE) {
		{
			std::lock_guard<std::mutex> lg{ g_PidPdMap_mtx };
			auto p = g_PidPdMap.find(e->dwParentProcessId);
			if (p == g_PidPdMap.end()) {
				if (szMalwareDirName[0] != '\0' && !ContainsWatchedDirectoryName(e->lpszFileName, szMalwareDirName)) return PROCFILTER_RESULT_NONE;
			}
		}
		
		const WCHAR *lpszCommandLine = e->GetProcessCommandLine();
		if (!lpszCommandLine) lpszCommandLine = L"*NONE*";

		WCHAR szParentName[MAX_PATH+1] = {0};
		e->GetProcessFileName(e->dwParentProcessId, szParentName, sizeof(szParentName));

		DWORD dwDialogResult = e->ShellNoticeFmt(0, true, MB_YESNO | MB_ICONQUESTION,
			L"Allow process?", L"Process name:%ls\nProcess Id:%u\nParent Name:%ls\nParent Id:%u\n\nCommand Line:\n\n%ls",
			e->lpszFileName, e->dwProcessId, szParentName, e->dwParentProcessId, lpszCommandLine);
		if (dwDialogResult != IDYES) return PROCFILTER_RESULT_BLOCK_PROCESS;

		dwDialogResult = e->ShellNoticeFmt(0, true, MB_YESNO | MB_ICONQUESTION,
			L"Watch process?", L"Process name:%ls\nProcess Id:%u", e->lpszFileName, e->dwProcessId);
		if (dwDialogResult == IDYES) {
			std::lock_guard<std::mutex> lg {g_PidPdMap_mtx};
			g_PidPdMap[e->dwProcessId] = ProcessData(e->lpszFileName);
		}
	} else if (e->dwEventId == PROCFILTER_EVENT_PROCESS_TERMINATE) {
		{
			std::lock_guard<std::mutex> lg {g_PidPdMap_mtx};
			auto p = g_PidPdMap.find(e->dwProcessId);
			if (p == g_PidPdMap.end()) return PROCFILTER_RESULT_NONE;
		}

		DWORD dwDialogResult = e->ShellNoticeFmt(0, true, MB_YESNO | MB_ICONQUESTION,
			L"Process terminating. Allow termination?", L"Process name:%ls\nProcess Id:%u", e->lpszFileName, e->dwProcessId);
		// This doesn't work due to x86/x64 differences
		//if (dwDialogResult == IDYES) DumpProcessMemory(e, L"C:\\unpack.dat");

		{
			std::lock_guard<std::mutex> lg {g_PidPdMap_mtx};
			auto p = g_PidPdMap.find(e->dwProcessId);
			if (p != g_PidPdMap.end()) g_PidPdMap.erase(p);
		}
	} else if (e->dwEventId == PROCFILTER_EVENT_IMAGE_LOAD) {
		WCHAR szProcessPath[MAX_PATH+1] = { 0 };

		bool bIsInWatchedDirectory = szMalwareDirName[0] != '\0' && ContainsWatchedDirectoryName(e->lpszFileName, szMalwareDirName);
		if (bIsInWatchedDirectory) {
			e->GetProcessFileName(e->dwProcessId, szProcessPath, sizeof(szProcessPath));
		} else {
			std::lock_guard<std::mutex> lg {g_PidPdMap_mtx};
			auto p = g_PidPdMap.find(e->dwProcessId);
			if (p == g_PidPdMap.end()) return PROCFILTER_RESULT_NONE;
			e->FormatString(szProcessPath, sizeof(szProcessPath), L"%ls", p->second.path.c_str());
		}
		
		dwResultFlags |= PROCFILTER_RESULT_BLOCK_PROCESS;
		DWORD dwDialogResult = e->ShellNoticeFmt(0, true, MB_YESNO | MB_ICONQUESTION,
			L"Allow image load?", L"Process Name:%ls\nProcess Id:%u\n\nImage name:%ls", szProcessPath, e->dwProcessId, e->lpszFileName);
		if (dwDialogResult == IDYES) {
			bool bWatched = false;
			{
				std::lock_guard<std::mutex> lg {g_PidPdMap_mtx};
				bWatched = g_PidPdMap.find(e->dwProcessId) != g_PidPdMap.end();
			}

			if (!bWatched) {
				dwDialogResult = e->ShellNoticeFmt(0, true, MB_YESNO | MB_ICONQUESTION,
					L"Watch process loading DLL?", L"Process Name:%ls\nProcess Id:%u\n\nImage Name:%ls",
					szProcessPath, e->dwProcessId, e->lpszFileName);
				if (dwDialogResult == IDYES) {
					std::lock_guard<std::mutex> lg {g_PidPdMap_mtx};
					g_PidPdMap[e->dwProcessId] = ProcessData(szProcessPath);
				}
			}

			dwResultFlags = PROCFILTER_RESULT_NONE;
		}
	} else if (e->dwEventId == PROCFILTER_EVENT_THREAD_CREATE) {
		std::wstring path;
		{
			// Determine if this is a watched process and if not, exit
			std::lock_guard<std::mutex> lg{g_PidPdMap_mtx};
			auto p = g_PidPdMap.find(e->dwProcessId);
			if (p == g_PidPdMap.end()) return PROCFILTER_RESULT_NONE;
			path = p->second.path;
		}

		HANDLE hNewPid = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, e->dwProcessId);
		if (!hNewPid) return PROCFILTER_RESULT_NONE; // Unable to open thread

		// Determine if thread is elevated
		bool bIsElevated = false;
		if (!e->IsElevated(hNewPid, &bIsElevated)) { // Unable to determine elevation
			CloseHandle(hNewPid);
			return PROCFILTER_RESULT_NONE;
		}

		// Don't watch elevated threads since suspending/blocking
		// some system threads can lead to blue screens
		if (!bWatchElevatedThreads && bIsElevated) {
			CloseHandle(hNewPid);
			return PROCFILTER_RESULT_NONE;
		}
	
		// Determine if thread is first thread
		ULONG64 ulProcessTime = 0;
		FILETIME ftUnused;
		FILETIME ftUserTime;
		bool bFirstThread = GetProcessTimes(hNewPid, &ftUnused, &ftUnused, &ftUnused, &ftUserTime) && (ftUserTime.dwHighDateTime == 0 && ftUserTime.dwLowDateTime == 0);
		bool bRemoteThread = !bFirstThread && e->dwParentProcessId != e->dwProcessId;
		CloseHandle(hNewPid);
		
		// Only get remote/local process names for a remote thread
		WCHAR szCreator[MAX_PATH+1] = {0};
		WCHAR szDestination[MAX_PATH+1] = {0};
		const WCHAR *lpszCreatorBaseName = L"";
		const WCHAR *lpszDestinationBaseName = L"";
		if (bRemoteThread) {
			if (e->GetProcessFileName(e->dwParentProcessId, szCreator, sizeof(szCreator)) && e->GetProcessFileName(e->dwProcessId, szDestination, sizeof(szDestination))) {
				lpszCreatorBaseName = e->GetProcessBaseNamePointer(szCreator);
				lpszDestinationBaseName = e->GetProcessBaseNamePointer(szDestination);
			} else {
				// Error getting filenames
			}
		}

		DWORD dwDialogResult = IDNO;
		dwResultFlags |= PROCFILTER_RESULT_BLOCK_PROCESS;
		std::wstring title;
		title.reserve(256);
		if (bRemoteThread) {
			title += L"Allow ";
			title += lpszCreatorBaseName;
			title += L"->";
			title += lpszDestinationBaseName;
			title += L" Remote Thread Creation?";
			dwDialogResult = e->ShellNoticeFmt(0, true, MB_YESNO | MB_ICONQUESTION,
				(WCHAR*)title.c_str(),
				L"Source Process:%ls\nSource Process Id:%u\n\nDestination Process:%ls\nDestination Process Id:%u\nDestination Thread Id: %u",
				szCreator, e->dwParentProcessId, szDestination, e->dwProcessId, e->dwThreadId);
		} else {
			title += L"Allow ";
			title += e->GetProcessBaseNamePointer((WCHAR*)path.c_str());
			title += L" Thread Creation?";
			dwDialogResult = e->ShellNoticeFmt(0, true, MB_YESNO | MB_ICONQUESTION,
				(WCHAR*)title.c_str(),
				L"Process Name:%ls\nProcess Id:%u\nThread Id:%u",
				path.c_str(), e->dwProcessId, e->dwThreadId);
		}
		
		if (dwDialogResult == IDYES) {
			dwResultFlags = PROCFILTER_RESULT_NONE;

			if (bRemoteThread) {
				bool bAskWatch = false;
				{
					std::lock_guard<std::mutex> lg {g_PidPdMap_mtx};
					bAskWatch = g_PidPdMap.find(e->dwProcessId) == g_PidPdMap.end();
				}

				if (bAskWatch) {
					dwDialogResult = e->ShellNoticeFmt(0, true, MB_YESNO | MB_ICONQUESTION,
						L"Watch target process?", L"Source Process:\n%ls\nSource Process Id:%u\n\nTarget Process:%ls\nTarget Process Id:%u",
							szCreator, e->dwParentProcessId, szDestination, e->dwProcessId);
					if (dwDialogResult == IDYES) {
						std::lock_guard<std::mutex> lg {g_PidPdMap_mtx};
						g_PidPdMap[e->dwProcessId] = ProcessData(szDestination);
					}
				}
			}
		}
	}

	return dwResultFlags;
}
